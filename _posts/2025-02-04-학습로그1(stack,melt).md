---
layout : post
title : "Pandas의 데이터 집계(stack, melt, pivot)"

categories:
  - learning log
tags:
  - [memo]

toc: true
toc_sticky: true
 
date: 2025-02-04 15:52:00 +0900
---

```
[학습 로그] 
Pandas 데이터 집계 - Stack과 Melt의 차이점

헷갈리는 것 
- 수업시간에 배운 stack, melt, pivot이 사용되는 용도를 잘 모르겠다.
- 그중에서도 stack과 melt의 차이점을 모르겠다.
- 간단한 DataFrame을 생성하여 적용해보며 이해해보자.

집계에 사용되는 stack, melt의 두 함수를 보면, 둘 다 컬럼을 아래로 내린다는 것 같은데,
정확히 이해가 되지 않았다. 그리고 컬럼에 카테고리 값이 있다면 집계를 할 수 없다는 말도
와닿지 않았다. 

주요 내용
- pivot, stack, melt 이란?
- DataFrame을 생성하여 stack과 melt를 적용해보며 차이점이 무엇인지 알아보자.


```
## 서론
학습로그를 처음 작성하기에 앞서, 내가 수업시간에 헷갈리던 부분이 무엇인가 작성한 코랩 파일을 하나씩 보며 되짚어봤다.
여러가지가 있었지만... 그 중에서도 잘 이해가 되지 않았던 stack과 melt가 눈에 들어왔다. 
중요한 집계 파트이기도 했고, melt가 중요하다고 말씀하신 거 같았기에 이번 기회에 확실히 개념을 잡고 넘어가면 좋을 거 같았다.
stack과 melt의 용도를 헷갈리기 전에, `집계`란 무엇인지 정확히 알고 가자. 
#### 집계란?
 여러 개의 값을 모아('집') 계산하여('계') 하나의 값으로 요약하는 과정이다.
대표적인 집계 함수로는 mean(), min(), max() 등이 있다.

 이때, 집계의 기준이 되는 데이터(집합)는 반드시 행(row) 단위여야 한다.
예를 들어, 데이터프레임의 컬럼이 ['이름', '국어', '수학', '영어']로 구성되어 있을 때,
'이름'이라는 컬럼 아래 존재하는 행 단위의 각 학생의 평균 점수를 계산하는 것은 가능하지만,
'과목'이라는 컬럼명이 존재하지 않는 상태에서는 '국어', '수학', '영어' 별로 집계를 수행할 수 없다.

이제 집계에 대해 이해했다. 
이러한 집계를 수행해주는 pandas의 함수들 중, stack과 melt의 차이점을 명확하게 이해해보자.
***
집계에 사용할 간단한 DataFrame을 생성한다.
```python
import pandas as pd

df = pd.DataFrame({
    "이름": ["철수", "영희", "민주", "은수"],
    "반" : ["A", "A", "B", "B"],
    "국어": [90, 85, 12, 100],
    "수학": [88, 92, 50, 90],
    "영어": [55, 90, 84, 72]
})
df
```
`[출력]`  
![](/images/../images/2025-02-05-22-09-27.png)

#### df의 index와 columns을 확인해보자
```python
# index 정보 확인
df.index
```
`[출력]`  
RangeIndex(start=0, stop=4, step=1)`
```python
# columns 정보 확인
df.columns
```
`[출력]`   
Index(['이름', '반', '국어', '수학', '영어'], dtype='object')
***

해당 df를 사용하여 stack, melt에 대해 자세히 이해해보자.
stack과 melt를 이해하기에 앞서, 보통의 DataFrame 컬럼은 멀티인덱스를 갖지 
않지 않는다. 따라서 pivot_table을 통해 집계를 시행하여 컬럼에 멀티인덱스를 만든 뒤에, stack과 melt를 적용해보자.

## pivot_table
- 컬럼에 있는 걸 index, columns, values, aggfunc을 지정해서 집계가 가능하다.
  - 매개변수에는 컬럼만을 지정할 수 있다.

#### pivot_table 생성 형식
```python
df_pivot = pd.pivot_table(
    df,
    index = "A",       # 행 인덱스로 사용할 컬럼
    columns = "B",     # 열(컬럼)으로 사용할 컬럼
    values = "C",       # 값으로 사용할 컬럼
    aggfunc = "mean"  # 값을 집계할 함수
)
```
#### pivot_table을 이용해 반 별 전체 과목 평균, 최소, 최대 값을 구해보자.
```python
# 반 별 과목 평균, 최소, 최대
df_pivot = pd.pivot_table(
    df,
    index = '반',
    values = ['국어','수학', '영어'],
    aggfunc = ['mean', 'min', 'max']
)
df_pivot
```
`[출력]`  
![](/images/../images/2025-02-05-22-11-30.png)

- columns에 MultiIndex가 생성되었다.
- columns의 MultiIndex level은 다음과 같다
- 표와 가까울수록 `하위 레벨`, 멀 수록 `상위 레벨`이다.
![](/images/../images/2025-02-05-23-05-38.png)

#### df_pivot의 index와 columns를 확인해보자
```python
df_pivot.index
```
`[출력]`  
Index(['A', 'B'], dtype='object', name='반')

```python
df_pivot.columns
```

`[출력]`
```
MultiIndex([('mean', '국어'),
            ('mean', '수학'),
            ('mean', '영어'),
            ( 'min', '국어'),
            ( 'min', '수학'),
            ( 'min', '영어'),
            ( 'max', '국어'),
            ( 'max', '수학'),
            ( 'max', '영어')],
           )
```
이렇게 표의 출력과 index와 columns를 확인을 통해 컬럼이 멀티인덱스로 변경됨을 확인할 수 있다.
이 상태에서 stack을 사용한다면 어떤 변화가 일어날까? 

스택의 특징은 다음과 같다. 
## stack

- 컬럼의 멀티인덱스를 레벨 단위로 행 인덱스로 내린다. 
  - 행 인덱스느 MultiIndex가 됨
  - 표가 가로로 너무 길 경우, 세로로 길게 만들 수 있음
- 집계를 하기 위한 기능은 아니다!
    - 멀티인덱스는 집계가 불가능하다.
- 결과적으로, 기존 표의 구조를 바꿔서 보기 쉽게 만든다.
- stack() 안에 컬럼 레벨을 지정하지 않으면 가장 하위레벨이 자동으로 선택 된다.

멀티인덱스는 집계의 '집', 즉 그룹을 모으는 과정에 사용할 수 없다. 그저 데이터를 구분하는 역할에 그친다.
컬럼이 멀티인덱스인 경우 가로로 표가 길어져 가독성이 떨어지기 때문에 stack을 통해 표의 구조를 보기 좋게 바꾼다.
따라서 stack은 표의 형태를 보기 좋게 바꾸는 데에 사용된다. 
#### stack() 사용 형식

```python
# 지정된 컬럼 레벨이 행 인덱스로 stack됨.
df.stack(컬럼레벨)
```
#### df_pivot에 stack 적용 후 결과 확인

##### 상위 레벨 선택 (level 0)
```python
# mean, min, max 컬럼을 행인덱스로
df_pivot.stack(0)
```
`[출력]`  
![](/images/../images/2025-02-05-22-45-30.png)

#### 하위 레벨 선택 (level 1)
```python
# 국어, 수학, 영어 컬럼을 행인덱스로
df_pivot.stack()
```
`[출력]`  
![](/images/../images/2025-02-05-22-44-35.png)

#### df_stack 생성
- df_stack에 df_pivot.stack()을 저장한다.
```python
df_stack = df_pivot.stack()
```
#### index와 columns를 확인해보자
```python
df_stack.index
```
`[출력]`  
```
MultiIndex([('A', '국어'),
            ('A', '수학'),
            ('A', '영어'),
            ('B', '국어'),
            ('B', '수학'),
            ('B', '영어')],
           names=['반', None])
```
- stack에 의해 내려온 `'국어', '수학', '영어'`컬럼들이 기존 컬럼인 `'반'`과 결합되어 `멀티인덱스`가 되었다.
```python
df_stack.columns
```
`[출력]`  
Index(['mean', 'min', 'max'], dtype='object')
***
- stack의 반대 개념인 unstack이 존재한다.
### unstack()
- 행의 멀티인덱스를 컬럼으로 올린다.
  - stack()의 반대개념이다.
- stack()을 실행한 DataFrame을 unstack()하면 처음 형태가 된다.

#### unstack() 사용 형식
```python
df.unstack(행 인덱스 레벨)
```
#### unstack()으로 다시 돌려 놓기
```python
df_stack.unstack()
```
`[출력]`   
![](/images/../images/2025-02-05-23-18-42.png)
- 행 인덱스의 가장 하위레벨이었던 '국어', '수학', '영어'가 컬럼인덱스의 가장 하위레벨이 되었다.
***
위의 과정을 통해, stack은 컬럼레벨을 행의 인덱스로 내린다는 것을 알게 되었다. 또한 stack을 통해 컬럼을 행 인덱스로
내리면, 인덱스가 합쳐져 멀티인덱스가 됨을 알았다. 멀티인덱스는 집계에서 사용하지 못 하기 때문에, stack은 그저 
가로로 긴 표를 세로로 길게 만들어주는, 표를 보기 좋게 바꿔주는 함수라고 생각할 수 있다.

이제 melt에 대해 알아보자.
melt의 특징들은 다음과 같다. 
## melt

- 기준을 잡은 컬럼들을 제외하고, 남은 컬럼들을 하나의 컬럼으로 녹임.
  - 녹일 컬럼을 직접 정할 수 있음

여기서 stack과의 차이를 볼 수 있다. 
- stack은 컬럼을 행인덱스로 변화하는 것이고, melt는 컬럼들을 기준에 맞춰 하나의 컬럼으로 녹이는 것이다.
그러나 와닿지 않기 떄문에 
#### melt() 사용법
```python
pd.melt(
  df,
  id_vars=[고정할 컬럼], value_vars=[녹일 컬럼], var_name="새 컬럼 이름", value_name="새 값 컬럼 이름")

```
#### melt()를 사용하여 국어, 수학, 영어를 과목이라는 하나의 컬럼으로 녹이기
```python
df_melt = df.melt(
    id_vars=['이름', '반'],
    var_name = '과목',
    value_name = '점수'
)
df_melt
```
`[출력]`  
![](/images/../images/2025-02-05-23-52-25.png)
- '국어', '수학', '영어'가 '과목'이라는 컬럼 하나로 녹았다.
- '국어', '수학', '영어'의 값은 '점수' 컬럼에 녹았다.
- 이제 과목별로 집계가 가능해졌다!
  #### 과목별 점수 평균 집계
  ```python
  df_t = df_melt.groupby("과목").mean(numeric_only=True) 
  df_t
  ```
  `[출력]`  
  ![](/images/../images/2025-02-05-23-55-09.png)



링크
- 참고 블로그
- 내 블로그 

