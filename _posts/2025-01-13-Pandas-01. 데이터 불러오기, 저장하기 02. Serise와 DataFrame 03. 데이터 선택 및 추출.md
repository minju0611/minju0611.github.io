---
layout : post
title : "Pandas-01. 데이터 불러오기, 저장하기 02. Serise와 DataFrame 03. 데이터 선택 및 추출"

categories:
  - Blog
tags:
  - [AI, Machine_Learning, TOSS, Pandas, Python ]

toc: true
toc_sticky: true
 
date: 2025-01-13 15:52:00 +0900
---
# 01. [Pandas] 데이터 불러오기 & 저장하기
## 데이터 불러오기 & 저장하기
### csv 불러오기
- Comma Seperated Values

### csv 파일 불러오기
```python
import pandas as pd

csv_file_path = "./data/titanic_train.csv"
df_csv = pd.read_csv(csv_file_path)
df_csv
```
```python
# index_col을 사용해서 인덱스 지정하기
df_csv = pd.read_csv("./data/titanic_train.csv", index_col = "PassengerId")
```
### 데이터프레임 정보 확인
```python
df_csv.info()
```

### 데이터의 일부 정보만 확인
```python
df_csv.head() # 상위 5개의 정보 확인
df_csv.tail(10) # 하위 10개의 정보 확인
```

## 웹 html 파일 불러오기
- 웹 페이지의 table태그(표)를 데이터 프레임으로 받아 올 수 있다.

```python
!pip install lxml html5lib 
```

```python
html_path = "https://finance.naver.com/sise/sise_quant.naver"

# utf-8이 기본! 안되면 euc-kr, 이것도 안되면 cp949, 이것도 안되면 엑셀로 
html_data_list = pd.read_html(html_path, encoding ='euc-kr')
html_data_list 

```
- html은 csv와 excel과 다르게 list형식으로 불러와지는 듯한
```python
df_kospi = html_data_list[1]
df_kospi.head()
# NaN : 값이 없다는 뜻 
```
```python
# 모든 값이 NaN이라면 해당 행을 삭제한 후, index를 다시 매긴다. (삭제된 index는 dataframe에 남기지 않고 drop한다.)
df_processed = df_kospi.dropna(how="all").reset_index(drop=True)
df_processed
```

### 파일 저장하기
```python
# dataframe을 csv로 저장하는 명령어, 저장할 파일의 경로와 이름도 지정
df_processed.to_csv("./data/kospi_processed_20250113.csv", encoding="utf-8")
```
# 02. [Pandas] Serise와 DataFrame

# 03. [Pandas] 데이터 선택 및 추출
```python

# 열 선택
df['Fare'] # 컬럼 이름을 적어 해당 시리즈(열)를 가져온다.
df.Fare

# 행 선택
df[:3] # 슬라이스 느낌으로 레코드(행) 가져온다.
```

```python
# serise를 2차원 배열인 df 형식으로 바꾸는 게 .to.frame()
df['Fare'].to_frame() # df는 2차원 배열, serise는 1차원 배열!!!!!!!!!!
```

```python
# Fancy Indexing 사용하기
columns = ['Survived',"Pclass","Name"]
df[columns]

# df를 조회할 때, 이렇게 list에 열을 넣고 조회하면 df형식으로 조회 됨!!!!
columns = ["survived"]
df[columns]
```

## loc, iloc

### loc
- `loc` : 이름 값을 활용해 조회

```python
df.loc[3] # 3번 행의 정보 (index의 3번째 아님 XXX)
```
```python
# loc[행 인덱스, 열 인덱스]
df.loc[3, "survived"]

# 행의 3~5까지의 컬럼이 "Name"인 것 (offset 인덱스가 아니기 때문)
df.loc[3:5, "Name"]

# 3 ~ 10 번 탑승객의 Name, Fare, Pclass 조회
columns = ["Name", "Fare", "Pclass"]
df.loc[3:10, columns]

```

```python
# 이런 식으로 행에도 list형식으로 넣을 수 있음.

# 1, 3, 5번 탑승객의 Age, Pclass
columns = ["Age", "Pclass"]
rows = [1, 3, 5]
df.loc[rows, columns]
```
### iloc
- integer location (offset index 사용)

```python
df.iloc[3:5, [2, 4, 5]]
# 출력 결과 :  3,4 행의 2,4,5(offset index기준)컬럼
```
## loc을 이용한 조건 추출 
### mask
- 행(레코드)에 대한 조건을 설정하여 원하는 조건에 맞는 행만 추출

```python
mask = df['Pclass'] == 1 # 각 인덱스에 대해 조건 검사 후 T/F로 구성된 값 추출
mask # 행인덱스 별 T/F 값으로 반환
```
```python
# 조건 마스크(mask = df['Pclass']==1)를 행에다 씌워서 True인 것만 추출
df.loc[mask] # mask는 뒤집어 씌우는 개념
```
```python
# AND, OR 조건
mask = (df["Pclass"] == 1) & (df["Age"] >= 30) # & : AND 조건
mask
```
```python
# AND, OR 조건
mask = (df["Pclass"] == 1) & (df["Age"] >= 30) # & : AND 조건
mask

mask = (df["Pclass"] == 1) | (df["Age"] >= 30) # & : AND 조건
mask
```
### isin 조건
```python
# 근데 그냥 웬만하면 loc 쓰라
mask = df["PassengerId"].isin([3, 100, 500]) 
df[mask]
```